{"version":3,"file":"replay.min.js","sources":["../src/replay.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * @module     tiny_cursive/replay\n * @category TinyMCE Editor\n * @copyright  CTI <info@cursivetechnology.com>\n * @author kuldeep singh <mca.kuldeep.sekhon@gmail.com>\n */\n\nimport { call as fetchJson } from 'core/ajax';\nimport templates from 'core/templates';\nimport $ from 'jquery';\nexport default class Replay {\n    controllerId = '';\n    constructor(elementId, filePath, speed = 1, loop = false, controllerId) {\n        this.controllerId = controllerId;\n        this.replayInProgress = false;\n        this.speed = speed;\n        this.loop = loop;\n        const element = document.getElementById(elementId);\n        if (element) {\n            this.outputElement = element;\n        } else {\n            throw new Error(`Element with id '${elementId}' not found`);\n        }\n        if (controllerId) {\n\n            this.constructController(controllerId);\n        }\n        this.loadJSON(filePath);\n        // .then((data) => {\n        //     if (data.status) {\n        //         var val = JSON.parse(data.data);\n        //         this.logData = val;\n        //         if (\"data\" in this.logData) {\n        //             this.logData = this.logData['data'];\n        //         }\n        //         if (\"payload\" in this.logData) {\n        //             this.logData = this.logData['payload'];\n        //         }\n        //         this.startReplay();\n        //     } else {\n        //         templates.render('tiny_cursive/no_submission').then(html => {\n        //             let updatedHtml = html.replace('No Submission', \"Something Went Wrong! or File Not Found!\");\n        //             $('.tiny_cursive').html(updatedHtml);\n        //         });\n        //     }\n        // })\n        // .catch(error => {\n        //     templates.render('tiny_cursive/no_submission').then(html => {\n        //         let updatedHtml = html.replace('No Submission', \"Something Went Wrong! or File Not Found!\");\n        //         $('.tiny_cursive').html(updatedHtml);\n        //     });\n        //     window.console.error('Error loading JSON file: ' + error.message);\n        // });\n    }\n\n    stopReplay() {\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n            this.replayInProgress = false;\n        }\n    }\n    constructController(controllerId) {\n        const controller = document.getElementById(controllerId);\n\n        if (controller) {\n            this.scrubberElement = document.createElement('input');\n            this.scrubberElement.type = 'range';\n            this.scrubberElement.id = 'timelineScrubber';\n            this.scrubberElement.min = '0';\n            this.scrubberElement.max = '100';\n            this.scrubberElement.addEventListener('input', () => {\n                const scrubberValue = this.scrubberElement.value;\n                this.skipToTime(scrubberValue);\n            });\n            controller.appendChild(this.scrubberElement);\n        }\n    }\n\n    setScrubberVal(value) {\n        if (this.scrubberElement) {\n            this.scrubberElement.value = String(value);\n        }\n    }\n\n    loadJSON(filePath) {\n        let filedata = this.processData(filePath);\n        if (filedata) {\n            var val = filedata;\n            this.logData = val;\n            if (\"data\" in this.logData) {\n                this.logData = this.logData['data'];\n            }\n            if (\"payload\" in this.logData) {\n                this.logData = this.logData['payload'];\n            }\n            this.startReplay();\n        } else {\n            templates.render('tiny_cursive/no_submission').then(html => {\n                let updatedHtml = html.replace('No Submission', \"Something Went Wrong! or File Not Found!\");\n                $('.tiny_cursive').html(updatedHtml);\n            });\n        }\n        // return fetchJson([{\n        //     methodname: 'cursive_get_reply_json',\n        //     args: {\n        //         filepath: filePath,\n        //     },\n        // }])[0].done(response => {\n        //     return response;\n        // }).fail(error => { throw new Error('Error loading JSON file: ' + error.message); });\n    }\n    processData(filePath) {\n        try {\n            // Attempt to parse as JSON\n            return JSON.parse(filePath);\n        } catch (error) {\n            // If JSON parsing fails, try Base64 decoding\n            try {\n                const decodedData = atob(filePath);\n                return JSON.parse(decodedData); // Attempt to parse the decoded data as JSON\n            } catch (error) {\n                // Handle the error, e.g., log the error or return a default value\n                window.console.error('Error parsing data:', error);\n                return null;\n            }\n        }\n    }\n    // call this to make a \"start\" or \"start over\" function\n    startReplay() {\n        // clear previous instances of timeout to prevent multiple running at once\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n        }\n        this.replayInProgress = true;\n        let uid = this.controllerId.split('_')[1];\n        let element = document.getElementById('rep' + uid);\n        let isactive = element.classList.contains('active');\n        if (!isactive) {\n            this.stopReplay();\n        } else {\n            this.outputElement.innerHTML = '';\n        }\n        this.replayLog();\n    }\n\n    // called by startReplay() to recursively call through keydown events\n    replayLog() {\n        let textOutput = \"\";\n        let index = 0;\n        const processEvent = () => {\n\n            if (this.replayInProgress) {\n                if (index < this.logData.length) {\n                    let event = this.logData[index++];\n                    if (event.event.toLowerCase() === 'keydown') { // can sometimes be keydown or keyDown\n                        textOutput = this.applyKey(event.key, textOutput);\n                    }\n                    this.outputElement.innerHTML = textOutput;\n                    this.setScrubberVal(index / this.logData.length * 100);\n                    this.replayTimeout = setTimeout(processEvent, 1 / this.speed * 100);\n                } else {\n                    this.replayInProgress = false;\n                    if (this.loop) {\n                        this.startReplay();\n                    }\n                }\n            }\n        };\n        processEvent();\n    }\n\n    skipToEnd() {\n        if (this.replayInProgress) {\n            this.replayInProgress = false;\n        }\n        let textOutput = \"\";\n        this.logData.forEach(event => {\n            if (event.event.toLowerCase() === 'keydown') {\n                textOutput = this.applyKey(event.key, textOutput);\n            }\n        });\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\n        this.setScrubberVal(100);\n    }\n\n    // used by the scrubber to skip to a certain percentage of data\n    skipToTime(percentage) {\n        if (this.replayInProgress) {\n            this.replayInProgress = false;\n        }\n        // only go through certain % of log data\n        let textOutput = \"\";\n        const numElementsToProcess = Math.ceil(this.logData.length * percentage / 100);\n        for (let i = 0; i < numElementsToProcess; i++) {\n            const event = this.logData[i];\n            if (event.event.toLowerCase() === 'keydown') {\n                textOutput = this.applyKey(event.key, textOutput);\n            }\n        }\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\n        this.setScrubberVal(percentage);\n    }\n\n    // used in various places to add a keydown, backspace, etc. to the output\n    applyKey(key, textOutput) {\n        switch (key) {\n            case \"Enter\":\n                return textOutput + \"\\n\";\n            case \"Backspace\":\n                return textOutput.slice(0, -1);\n            case \"ControlBackspace\": {\n                let lastSpace = textOutput.lastIndexOf(' ');\n                return textOutput.slice(0, lastSpace);\n            }\n            default:\n                return ![\"Shift\", \"Ctrl\", \"Alt\", \"ArrowDown\", \"ArrowUp\", \"Control\", \"ArrowRight\", \"ArrowLeft\", \"Meta\"]\n                    .includes(key) ? textOutput + key : textOutput;\n        }\n    }\n}\n"],"names":["constructor","elementId","filePath","speed","loop","controllerId","replayInProgress","element","document","getElementById","Error","outputElement","constructController","loadJSON","stopReplay","this","clearTimeout","replayTimeout","controller","scrubberElement","createElement","type","id","min","max","addEventListener","scrubberValue","value","skipToTime","appendChild","setScrubberVal","String","filedata","processData","val","logData","startReplay","render","then","html","updatedHtml","replace","JSON","parse","error","decodedData","atob","window","console","uid","split","classList","contains","innerHTML","replayLog","textOutput","index","processEvent","length","event","toLowerCase","applyKey","key","setTimeout","skipToEnd","forEach","slice","percentage","numElementsToProcess","Math","ceil","i","lastSpace","lastIndexOf","includes"],"mappings":"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"}